//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { BaseClient } from './baseClient';

export interface IApiClient {

    postApiAuthRegister(registration: RegisterRequest, signal?: AbortSignal): Promise<void>;

    postApiAuthLogin(login: LoginRequest, useCookies?: boolean | null | undefined, useSessionCookies?: boolean | null | undefined, signal?: AbortSignal): Promise<AccessTokenResponse>;

    postApiAuthRefresh(refreshRequest: RefreshRequest, signal?: AbortSignal): Promise<AccessTokenResponse>;

    getApiAuthConfirmEmail(userId: string | null, code: string | null, changedEmail?: string | null | undefined, signal?: AbortSignal): Promise<void>;

    postApiAuthResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest, signal?: AbortSignal): Promise<void>;

    postApiAuthForgotPassword(resetRequest: ForgotPasswordRequest, signal?: AbortSignal): Promise<void>;

    postApiAuthResetPassword(resetRequest: ResetPasswordRequest, signal?: AbortSignal): Promise<void>;

    postApiAuthManage2fa(tfaRequest: TwoFactorRequest, signal?: AbortSignal): Promise<TwoFactorResponse>;

    getApiAuthManageInfo(signal?: AbortSignal): Promise<InfoResponse>;

    postApiAuthManageInfo(infoRequest: InfoRequest, signal?: AbortSignal): Promise<InfoResponse>;

    getRecurrenceRules(signal?: AbortSignal): Promise<RecurrenceRuleDto[]>;

    createRecurrenceRule(request: CreateRecurrenceRuleRequest, signal?: AbortSignal): Promise<number>;

    getRecurrenceRule(id: number, signal?: AbortSignal): Promise<RecurrenceRuleDto>;

    updateRecurrenceRule(id: number, request: UpdateRecurrenceRuleRequest, signal?: AbortSignal): Promise<boolean>;

    deleteRecurrenceRule(id: number, request: DeleteRecurrenceRuleRequest, signal?: AbortSignal): Promise<boolean>;

    getTaskLists(signal?: AbortSignal): Promise<TaskListDto[]>;

    createTaskList(request: CreateTaskListRequest, signal?: AbortSignal): Promise<number>;

    getTaskList(id: number, signal?: AbortSignal): Promise<TaskListDto>;

    updateTaskList(id: number, request: UpdateTaskListRequest, signal?: AbortSignal): Promise<boolean>;

    deleteTaskList(id: number, signal?: AbortSignal): Promise<boolean>;

    getTasks(startDate?: Date | null | undefined, endDate?: Date | null | undefined, signal?: AbortSignal): Promise<TaskDto[]>;

    createTask(request: CreateTaskRequest, signal?: AbortSignal): Promise<number>;

    getTask(id: number, signal?: AbortSignal): Promise<TaskDto>;

    updateTask(id: number, request: UpdateTaskRequest, signal?: AbortSignal): Promise<boolean>;

    deleteTask(id: number, signal?: AbortSignal): Promise<boolean>;

    getTodoItems(signal?: AbortSignal): Promise<TodoItemDto[]>;

    createTodoItem(command: CreateTodoItemCommand, signal?: AbortSignal): Promise<number>;

    getTodoItem(id: number, signal?: AbortSignal): Promise<TodoItemDto>;
}

export class ApiClient extends BaseClient implements IApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    postApiAuthRegister(registration: RegisterRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthRegister(_response);
        });
    }

    protected processPostApiAuthRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    postApiAuthLogin(login: LoginRequest, useCookies?: boolean | null | undefined, useSessionCookies?: boolean | null | undefined, signal?: AbortSignal): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Auth/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthLogin(_response);
        });
    }

    protected processPostApiAuthLogin(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccessTokenResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    postApiAuthRefresh(refreshRequest: RefreshRequest, signal?: AbortSignal): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthRefresh(_response);
        });
    }

    protected processPostApiAuthRefresh(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccessTokenResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    getApiAuthConfirmEmail(userId: string | null, code: string | null, changedEmail?: string | null | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/confirmEmail?";
        if (userId === undefined)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined)
            throw new globalThis.Error("The parameter 'code' must be defined.");
        else if(code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApiAuthConfirmEmail(_response);
        });
    }

    protected processGetApiAuthConfirmEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    postApiAuthResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthResendConfirmationEmail(_response);
        });
    }

    protected processPostApiAuthResendConfirmationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    postApiAuthForgotPassword(resetRequest: ForgotPasswordRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthForgotPassword(_response);
        });
    }

    protected processPostApiAuthForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    postApiAuthResetPassword(resetRequest: ResetPasswordRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthResetPassword(_response);
        });
    }

    protected processPostApiAuthResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    postApiAuthManage2fa(tfaRequest: TwoFactorRequest, signal?: AbortSignal): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/api/Auth/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthManage2fa(_response);
        });
    }

    protected processPostApiAuthManage2fa(response: Response): Promise<TwoFactorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TwoFactorResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    getApiAuthManageInfo(signal?: AbortSignal): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/api/Auth/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApiAuthManageInfo(_response);
        });
    }

    protected processGetApiAuthManageInfo(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InfoResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    postApiAuthManageInfo(infoRequest: InfoRequest, signal?: AbortSignal): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/api/Auth/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiAuthManageInfo(_response);
        });
    }

    protected processPostApiAuthManageInfo(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InfoResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HttpValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    getRecurrenceRules(signal?: AbortSignal): Promise<RecurrenceRuleDto[]> {
        let url_ = this.baseUrl + "/api/RecurrenceRules";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecurrenceRules(_response);
        });
    }

    protected processGetRecurrenceRules(response: Response): Promise<RecurrenceRuleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RecurrenceRuleDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecurrenceRuleDto[]>(null as any);
    }

    createRecurrenceRule(request: CreateRecurrenceRuleRequest, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/RecurrenceRules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRecurrenceRule(_response);
        });
    }

    protected processCreateRecurrenceRule(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    getRecurrenceRule(id: number, signal?: AbortSignal): Promise<RecurrenceRuleDto> {
        let url_ = this.baseUrl + "/api/RecurrenceRules/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecurrenceRule(_response);
        });
    }

    protected processGetRecurrenceRule(response: Response): Promise<RecurrenceRuleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RecurrenceRuleDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecurrenceRuleDto>(null as any);
    }

    updateRecurrenceRule(id: number, request: UpdateRecurrenceRuleRequest, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/RecurrenceRules/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateRecurrenceRule(_response);
        });
    }

    protected processUpdateRecurrenceRule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    deleteRecurrenceRule(id: number, request: DeleteRecurrenceRuleRequest, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/RecurrenceRules/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRecurrenceRule(_response);
        });
    }

    protected processDeleteRecurrenceRule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getTaskLists(signal?: AbortSignal): Promise<TaskListDto[]> {
        let url_ = this.baseUrl + "/api/TaskLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTaskLists(_response);
        });
    }

    protected processGetTaskLists(response: Response): Promise<TaskListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskListDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskListDto[]>(null as any);
    }

    createTaskList(request: CreateTaskListRequest, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/TaskLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateTaskList(_response);
        });
    }

    protected processCreateTaskList(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    getTaskList(id: number, signal?: AbortSignal): Promise<TaskListDto> {
        let url_ = this.baseUrl + "/api/TaskLists/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTaskList(_response);
        });
    }

    protected processGetTaskList(response: Response): Promise<TaskListDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskListDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskListDto>(null as any);
    }

    updateTaskList(id: number, request: UpdateTaskListRequest, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/TaskLists/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTaskList(_response);
        });
    }

    protected processUpdateTaskList(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    deleteTaskList(id: number, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/TaskLists/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteTaskList(_response);
        });
    }

    protected processDeleteTaskList(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getTasks(startDate?: Date | null | undefined, endDate?: Date | null | undefined, signal?: AbortSignal): Promise<TaskDto[]> {
        let url_ = this.baseUrl + "/api/Tasks?";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTasks(_response);
        });
    }

    protected processGetTasks(response: Response): Promise<TaskDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto[]>(null as any);
    }

    createTask(request: CreateTaskRequest, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateTask(_response);
        });
    }

    protected processCreateTask(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    getTask(id: number, signal?: AbortSignal): Promise<TaskDto> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTask(_response);
        });
    }

    protected processGetTask(response: Response): Promise<TaskDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto>(null as any);
    }

    updateTask(id: number, request: UpdateTaskRequest, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTask(_response);
        });
    }

    protected processUpdateTask(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    deleteTask(id: number, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteTask(_response);
        });
    }

    protected processDeleteTask(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getTodoItems(signal?: AbortSignal): Promise<TodoItemDto[]> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTodoItems(_response);
        });
    }

    protected processGetTodoItems(response: Response): Promise<TodoItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TodoItemDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoItemDto[]>(null as any);
    }

    createTodoItem(command: CreateTodoItemCommand, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateTodoItem(_response);
        });
    }

    protected processCreateTodoItem(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    getTodoItem(id: number, signal?: AbortSignal): Promise<TodoItemDto> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTodoItem(_response);
        });
    }

    protected processGetTodoItem(response: Response): Promise<TodoItemDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TodoItemDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoItemDto>(null as any);
    }
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface HttpValidationProblemDetails extends ProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export interface RegisterRequest {
    email?: string;
    password?: string;
}

export interface AccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;
}

export interface LoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export interface RefreshRequest {
    refreshToken?: string;
}

export interface ResendConfirmationEmailRequest {
    email?: string;
}

export interface ForgotPasswordRequest {
    email?: string;
}

export interface ResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;
}

export interface TwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;
}

export interface TwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export interface InfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;
}

export interface InfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export interface BaseEntityDto {
    id?: number;
}

export interface BaseAuditableEntityDto extends BaseEntityDto {
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date;
    lastUpdatedBy?: string | undefined;
}

export interface RecurrenceRuleDto extends BaseAuditableEntityDto {
    rRule?: string;
    startDate?: Date;
    endDate?: Date | undefined;
    maxOccurrences?: number | undefined;
    taskTitle?: string;
    taskDescription?: string;
    taskPriority?: TaskPriority;
    lastGeneratedUntil?: Date | undefined;
    generatedCount?: number;
    isActive?: boolean;
}

export enum TaskPriority {
    Low = 0,
    Medium = 1,
    High = 2,
}

export interface CreateRecurrenceRuleRequest {
    rRule?: string;
    startDate?: Date;
    endDate?: Date | undefined;
    maxOccurrences?: number | undefined;
    taskTitle?: string;
    taskDescription?: string;
    taskPriority?: TaskPriority;
}

export interface UpdateRecurrenceRuleRequest {
    id?: number;
    rRule?: string;
    startDate?: Date;
    endDate?: Date | undefined;
    maxOccurrences?: number | undefined;
    taskTitle?: string;
    taskDescription?: string;
    taskPriority?: TaskPriority;
    isActive?: boolean;
}

export interface DeleteRecurrenceRuleRequest {
    id?: number;
    deleteFutureTasks?: boolean;
}

export interface TaskListDto extends BaseAuditableEntityDto {
    title?: string;
    color?: string;
    tasks?: TaskDto[];
}

export interface TaskDto extends BaseAuditableEntityDto {
    title?: string;
    description?: string;
    dueDate?: Date;
    priority?: TaskPriority;
    completed?: boolean;
    completedAt?: Date;
    recurrenceRuleId?: number | undefined;
    parentTaskId?: number | undefined;
    parentTask?: Task | undefined;
    taskListId?: number | undefined;
    taskList?: TaskListDto | undefined;
}

export interface BaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export interface BaseAuditableEntity extends BaseEntity {
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    lastUpdatedBy?: string | undefined;
}

export interface Task extends BaseAuditableEntity {
    title?: string;
    description?: string;
    dueDate?: Date;
    priority?: TaskPriority;
    completed?: boolean;
    completedAt?: Date;
    parentTaskId?: number | undefined;
    parentTask?: Task | undefined;
    taskListId?: number | undefined;
    taskList?: TaskList | undefined;
    recurrenceRuleId?: number | undefined;
    recurrenceRule?: RecurrenceRule | undefined;
}

export interface TaskList extends BaseAuditableEntity {
    title?: string;
    color?: string;
    tasks?: Task[];
}

export interface BaseEvent {
}

export interface RecurrenceRule extends BaseAuditableEntity {
    rRule?: string;
    startDate?: Date;
    endDate?: Date | undefined;
    maxOccurrences?: number | undefined;
    taskTitle?: string;
    taskDescription?: string;
    taskPriority?: TaskPriority;
    lastGeneratedUntil?: Date | undefined;
    generatedCount?: number;
    isActive?: boolean;
    generatedTasks?: Task[];
}

export interface CreateTaskListRequest {
    title?: string;
    color?: string;
}

export interface UpdateTaskListRequest {
    id?: number;
    title?: string;
    color?: string;
}

export interface CreateTaskRequest {
    taskListId?: number | undefined;
    title?: string;
    description?: string;
    dueDate?: Date;
    priority?: TaskPriority;
}

export interface UpdateTaskRequest {
    taskListId?: number | undefined;
    id?: number;
    title?: string;
    description?: string;
    dueDate?: Date;
    priority?: TaskPriority;
}

export interface TodoItemDto extends BaseAuditableEntityDto {
    title?: string;
}

export interface CreateTodoItemCommand {
    title?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* extensionCode doesn't work without this comment :S */